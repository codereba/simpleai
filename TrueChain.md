# 初链黄皮书解读  

### 术语：  

慢链：snailchain  
fPoW： fruit chain PoW  

## 1.概述：  

## 区块链技术特点： 
基于现实中广为认同的共识机制，（自然的）具备去中心化特性，以及交易信息透明，独立自治（不被外部影响），不可篡改特性  
是加密货币的关键技术  

### 经典（早期）的共识机制，对应的项目，特点： 
PoW        Bitcoin,Ethereum       交易传输速率低，不具有能源消耗，计算能力的经济上可持续性 但去中心化性（1/2容错性），安全性高（验证节点数多，难以攻击）  
PoS                                       交易传输速率高，但区块的验证过程受权益最多的小部分节点影响过大（去中心化性不足）安全性低（验证节点数少）  
DPoS      bitshare                    交易传输速率高，但区块的验证过程由代理节点决定，而代理节点选举过程受权益最多的小部分节点影响过大 去中心化性不足  安全性低（验证节点数少）  
PBFT       (私有链、联盟链)          交易传输速率更高，去中心化性不足（ 1/3 的容错性） 安全性低（验证节点数少，要求节点之间彼此信任），网络可扩展性不足  

区块链技术的“高效低能” “去中心化” “安全” 不可能三解之间的最佳的平衡方案（质与量）是当前它面对的最重要的问题。  
初链的解决方案是结合PBTF和PoW共识  
PBFT共识  
在深入分析论文《The sleepy model of consensus》R. Pass, E. Shi的混合共识协议基础上做了更多的优化和设计。  
1.交易传输速率高，即时验证，确认交易（相对bitcoin需要6个或以上的块确认，ethereum一般需要12个或以上的块），不同质（IPFS网络存储矿机等）节点的支持。 
  
PoW共识  
1.用来选举BFT委员会成员（基于结块量与权益（资产）抵押量），保障委员会成员不被控制或者攻击  
2.公平有效的激励模型（针对PoW共识定义snailchain，结合 水果链（fruitchain），变成了fPoW，更公平有效的激励机制）  
特点：  
将PBFT共识机制应用的范围从私有链与联盟链扩展为公有链  
去中心化（PoW特性），安全性（1/3 的容错性），交易传输，验证，确认速度，低能耗（PBFT特性)，做到更佳的平衡。  

相较当前的多共识方案具有一定的优势：  
eos                                          BFT+DPoS  交易速率更大提升  安全性没有本质改变  
ethereum(Hybrid Casper)                  PoW+PoS    更加平衡的方案  
核心理念：
为高性能行业应用设计，提供高效的智能合约机制，比如广告，游戏等行业，区块链4.0概念。  
  
## 2.初链核心技术  
### 1. 水果链对比Nakamoto（传统）链：  
都属于慢链  
* 传统链的问题：  
  自私挖矿：  
  1. 恶意矿工挖到矿，故意不接到原来的链上，而是继续往下挖，挖到更长的链。  
  2. 诚实矿工挖到矿接到原来的链，但相对恶意矿工挖到的链更短，恶意矿工与其竞争，使诚实矿工的努力白费。  
  3. 恶意矿工控制>25%算力，可以控制>33%的块的生产。（如果与BFT混合共识，结块点的比率决定了选举为BFT成员的概率，>33%将会破坏整个共识机制）。控制>40%算力，通过强化的自私算法，可以控制>70%的块的生产。（如果与BFT混合共识，可以独断的控制整个BFT委员会）  
  联合挖矿：  
   1. 多节点联合，组成巨大的hash算力，单节点相对hash算力非常低，挖矿成功难度非常高，公平不足。  
   2. 多节点联合，可能进行51%攻击  
  3. 可能会部署专用的ASIC矿机  
  交易费不稳定：  
   1. 矿工优先打包交易费高的交易，于是为了交易确认的效率，交易手续费设置不同的量，不稳定。  
  交易确认速度很慢，高能耗  
* 水果链的特点：  
   1.容错性是1/3-a，a是一个很小的随机常数。  
   2.基于统一的算法h，当h-κ<Dpf时开采果实，当hκ<Dp时开采块，其中Dpf和Dp分别是果实和块的采矿难度系数。元组（R，Dp，Dpf）用来决定采矿过程，采矿难度相对更小，预期的水果和块的挖矿时间分别为1秒和10分钟，所以矿工没有动力加入矿池，更加公平。可以避免以上传统链的缺点。  
  3.通过VRF每3个月更新一次参数k，阻止ASIC矿机运算。  
  4. 果实可以任何顺序挖矿，可以高度平行。与分片结合，特别有用。  
    
   参考：https://github.com/truechain/truechain-fpow   
   其中的区块数头据结构定义：
// Header represents a block header in the Ethereum blockchain. FruitsHash support.  
type Header struct {  
	ParentHash common.Hash `json:"parentHash"       gencodec:"required"`  
  
	PointerHash  common.Hash `json:"pointerHash"      gencodec:"required"`  
	FruitsHash   common.Hash `json:"fruitSetHash"     gencodec:"required"`  
	RecordHash   common.Hash  
	RecordNumber *big.Int  
	Fruit		bool  
  
	UncleHash   common.Hash    `json:"sha3Uncles"       gencodec:"required"`  
	Coinbase    common.Address `json:"miner"            gencodec:"required"`  
	Root        common.Hash    `json:"stateRoot"        gencodec:"required"`  
	TxHash      common.Hash    `json:"transactionsRoot" gencodec:"required"`  
	ReceiptHash common.Hash    `json:"receiptsRoot"     gencodec:"required"`  
	Bloom       Bloom          `json:"logsBloom"        gencodec:"required"`  
	Difficulty  *big.Int       `json:"difficulty"       gencodec:"required"`  
	Number      *big.Int       `json:"number"           gencodec:"required"`  
	GasLimit    uint64         `json:"gasLimit"         gencodec:"required"`  
	GasUsed     uint64         `json:"gasUsed"          gencodec:"required"`  
	Time        *big.Int       `json:"timestamp"        gencodec:"required"`  
	Extra       []byte         `json:"extraData"        gencodec:"required"`  
	MixDigest   common.Hash    `json:"mixHash"          gencodec:"required"`   
	Nonce       BlockNonce     `json:"nonce"            gencodec:"required"`  
}  
  
### 2. 智能合约与虚拟机  
尽管一个链码可以部署在一个容器中,但这对于公链来说显然是无法规模化的。一个同时运行几千个智能合约的公链意味着需要几千个容器,但数千个容器显然是不现实的,所以只能选择限制同时运行的智能合约数量。  
超级账本的Fabric框架合用容器代替虚拟机来执行智能合约，把Fabric的权限化的属性改成去权限化，面临的第一个挑战就是chaincode的问题，虽然可以将一个chaincode或智能合约放在一个容器里，但这对公链来说不是一个可扩展模型，意味着每个节点可能有几千个容器来运行对应的几千个智能合约（因为每个节点都维护一份拷贝），通过社区测试，一个节点运行的最多容器数限额目前是100个pod，大约250个容器，最大值是1000个（MAX CONTR ）。大家一般倾向于水平扩展规模而不是垂直扩展容量，这是因为后者极大地增加了设计决策的复杂度，以太坊目前部署有至少几千个智能合约，因此这已经变成优化容器生态的设计问题了。  
初链基础架构在全节点整合EVM和TVM（类似EVM的权限化的字节码执行引擎）来运行智能合约，EVM处理POW共识，TVM处理PBFT共识，支持DailyBFT。  
使用EVM来执行智能合约的一个原因是使用Gas字段来评估交易的手续费：  
1. 通过限制区块GAS的上限来达到定义区块内存大小的作用。  
2. 平衡了普通转账交易和复杂智能合约交易的手续费，更加公平。  
   
### 3. 节点选取  
现在BFT委员会节点选取多采用固定时间(慢链作为逻辑时钟)换届选举慢链最近的N个块的矿工节点成为新的委员会成员（N是委员会成员的数量）。  
但如果节点的工作完善，则不强制它进行选举，也避免高频次的重新选举额外消耗的性能，但如果所有委员会节点都保持良好的工作记录，新节点就难以加入委员会。  
平衡方案是即每隔一段时间更换一次节点，但更换频率非常低（如每K天重新选举一次），但同时借鉴了Thunderella的想法，即慢链(snailchain PoW共识)可以证明BFT成员造假或出错情况，一旦发生，次日即进行委员会重新选举。 
  
一般混合共识机制是选举慢链最近的N个块的矿工节点成为新的委员会成员，初链是权益证明和随机选取相结合的方式，全节点临时性抵押它们的代币资产，选取抵押资产最高n\*N个节点成为委员会成员（n=[0,1]，另外部分(1-n)\*N个委员会成员按照VRF随机过程选取，随机过程的种子由上一次选举的种子和由最近的N个块产生的随机熵确定，不同于Algorand算法，此阶段将不会计算权益比例。  
随机过程选取的节点很可能不在线，避免不在线的节点严重影响拜占庭共识，设置r\*n<f/N（r是估计的不在线节点的比率），通常配置n=f/(2\*r\*N)，同时也有方案允许不在线的节点，参考《The sleepy model of consensus 》。掌握巨大运算资源，操纵VRF随机值的概率非常小，可以忽略。  
  
BFT节点选取算法平衡随机性与算力：  
随机性过大（VRF）容易受到女巫攻击（Sybil Attack)  
算力为主容易被算力强大矿池控制  
解决方案是当最诚实的BFT节点的数量达到了L，将把最近生产的块中的每个水果的矿工的ID（或者大于V个水果的矿工的ID）的序列加入BFT委会员候选人列表，再通过VRF随机选取最终的BFT委员会成员。  
1. 因为需要挖矿才能参与选举，所以可抑制女巫攻击  
2. 因为随机性，同时水果的挖矿难度大大降低，所以强大的算力也不足以控制BFT委员会。  
  
### 4. 针对高性能行业应用设计：  
物理时间限制：  
传统的共识设计允许矿工/委员会节点在一个小的时间窗口内重新安排交易，这给一些分布式应用带来了问题，如商业交易所，公平性要求交易之间的时间顺序必须严格的保持，否则恶意节点可能会重新排列交易，甚至插入自己的交易，以获得额外的利润。在高频度的交易中可能性更大， 更糟糕的是这样的恶意重新排序是无法区分的，因为网络等待时间将导致重新排序，并且这种延迟只能由交易的接收节点本身观察到。  
使用被称为粘性时间戳的规范来减少这些问题，在提出交易时，客户端输入物理时间戳（在时间间隙T后）在交易的元数据中，并与交易的其他部分一起进行签名，BFT验证  交易的过程：  
1. 在BFT内部实现日志的阶段，委员会节点根据交易的物理时间进行排序，如果时间相同，使用序列号排序（可能性很小），其实之后的评估和验证过程也可以强制排序。  
1. 来自任何节点的交易根据其物理时间戳排序，因此交易的顺序被严格执行，消除来自同一恶意节点的多次交易重新排序的可能性。  
2. 由BFT委员会输出的交易序列中的顺序严格按时间戳排序。  
3. 因为时间窗的限制（BFT节点做时间标准），节点不能产生假的物理时间戳。   
缺点：  
1. 当时间间隙T不适合变化的网络延迟时，可能会中断某些交易导致吞吐量下降。  
2. BFT委员会成员仍然可以谎报当地时间，拒绝某些交易，同时因为时钟不同步，诚实的节点也可能会拒绝交易。通过增加对BFT委员会职能的限制来减少这种情况，如委员会的节点应该提供同步时钟的证据。 
  
参考代码：  
Data: Input Transaction TX  
Result: A Boolean value that indicates whether the verification is passed   
current_time ← Time.Now();   
if |current time − TX.| >  then  
   return false;  
// if the time skew is too large, reject TX.  
var txn_history = new static dictionary of lists;   
if txn_history[TX.from] == NULL then  
    txn_history[TX.from] == [TX ];   
else  
     if txn_history[TX.from][−1]. − TX. > 0 then   
         return false;  
              // To make sure the transactions from the same node preserve timing order.  
     else  
         txn_history[TX.from].append(TX);   
         return true;  
  
### 5. 分片技术  
确定的实例序列DailyBFT [1 ... R]构成一个分片，可以同时存在多个分片，分为普通分片（为了简化，固定数量为C）和主分片（包括N个节点）两类，主分片确定普通分片输出的顺序，调度普通分片之间的交易传输，普通分片输出到主分片（交易日志等），主分再输出到混合共识。  
多个分片不可以有共同的节点，通过选举过程来保证。  
把所有帐户的状态数据均匀的分C个分片，确保对相应的分片的所有查询都返回状态一致。将数据拆分到数据节的数据单元中来保存元数据，并为每个数据节分配一个地址，建立数据指针到数据扇区地址的映射。  
每个数据节DS[addr]都有rts，wts，readers， writers元数据，通过调用函数host(addr)来得到数据节的分片， 每个正常的分片(当对方的分片数量不多)是一个分布式处理单元处理，可以使用逻辑时间戳分布式交易处理系统中，来增强交易的处理能力。使用简化的MaaT版本，不对其他交易的时间戳进行自动调整，改变普通分片来执行并行计算之外，普通分片严格按照DailyBFT的规范执行。  
主分片收集普通分片的输出，交易的依赖性可以从它的元数据里推导，一个交易如果用到多个远程分片，会在远程分片上留下信息，当普通分片提交日志给主分片时，会写到慢链上。  
当主分片收到（或者从慢链抓取）一个分版本的交易序列，会检查是否收到所有分片的交易构成的完整交易序列，如果在一段时间内没有收到交易序列的所有交易，那么这批次交易失败，第二天进行委员会的重新选举，当主分片收到所有分片的交易构成的完整交易序列，会根据提交的时间戳排序（交易序列号是排序的第一参数，但如果某个分片的物理时间戳与其它分片的物理时间戳冲突，则交易序列是无效的，所有的交易都放弃），排序后，主分片将最长的物理时间戳非递减交易序列发送到混合共识模块，做为每天的日志。  
缺点：确认时间不是实时的。  
  
分片技术的类型：  
  
基于trace对交易进行标注：典型的就是Chainspace。交易注入到网络中之前，先模拟trace，并以此标注出可能与其他交易冲突的地方，然后再根据这些冲突发到相关的分片中处理，相关的分片之间再用S-BAC去共识。这种方法，我想应该还是不能完全依照trace，还必须在代码层面进行标注，否则一个if/else语句在trace环境和实际环境下就可能走向了截然不同的分支。另外每一个交易可能的冲突都要相关的分片之间去跑一轮共识，一个分片如果牵涉到很多个这样的交易，那每一次就要跟不同的分片跑很多个这样的共识。  
  
交易分裂：典型的就是Ethereum。首先要说明的是，这种方式交易只能类似于币的转移这种，从一个分片中的地址，转移到另一个分片中的地址。合约内部状态是不能共享的，必须要保证每个分片的状态是私有的。具体的做法就是将这个币的转移过程切开，分成币的发送+币的接受，并且在不同的共识周期中完成。具体在Ethereum中的话，在一个共识周期中，分片中的地址发送币，并在主链中产生一个收据，然后在下一个共识周期中，另一个分片中的地址依据这个收据接受币。看起来简单，然而并非如此，可以用火车和旅馆问题来比喻。你要去另一个城市玩，要定火车票，还要定旅馆。倘若你定了火车票，但是旅馆没订到，那就麻烦了；倘若你旅馆订到了，但是火车票没订到，你也麻烦了。要么都订到，要么都没订到，那才是良好的状态。问题产生的原因就是交易分裂到多个共识周期，破坏了原子性。Ethereum目前在这一块还处于初步的理论研究阶段，计划在分片的第四期中实现。Zilliqa的白皮书中将跨分片作为future work，据说正在研究，但从他们和Ethereum社区的交互来看，应该是同一种思想。这种方案一个很显而易见的开销，是需要至少个共识周期参与，需要双倍的时间。  
  
跨分片的交易在父级分片中处理：以名字空间机制作为基础，这种解决方式是直观显而易见的，而别的区块链项目因为没有多级名字空间这个基础设施，无法应用该方案。这种方案实现相对简单，稳定可靠，可以支持的交易比较灵活，适应面广，并且只需要一个共识周期就可以确认。但是，这种方案一个明显的缺点就是，父级分片存在处理压力的汇聚问题，越是上级的分片对吞吐率的要求越高。RChain的解决方案是鼓励交易尽量在低层分片解决。一方面，多级分片结构具有过滤作用，需要处理的分片比例随着分片层级的升高而越来越低。需要说明的是：名字空间非常有利于数据的局部性，类似于CPU的缓存；而Ethereum那种按照地址前缀分配分片的做法，数据完全是随机的，没有局部性。另一方面，越上级的名字空间处理费用越高，通过经济激励手段让合约只在必要的时候才跨分片，只在非常必要的时候才跨高层次的分片。这个过程可以类比汇款：同城汇款免费秒到，北京的汇款在北京分行内部就解决了，跟上海分行没关系；跨省汇款可能有时延，并且收首先费，总行可以解决；跨国汇款价格贵多了，而且要好几天的时间，通过swift才能解决。  
  
初链方案是trace对交易进行标注。    
  
### 6. 异质的基础架构:  
  
存储：
  
级别1 存储在每个PoW节点上，比如以太坊。最永久的存储方式，也是效率最低的方式。最好存储空间占用较少的数据，和必须的基础数据（区块等）。
  
级别2 类似IPFS的文件系统将数据的部分副本分发给整个链中的存储节点，通常用于True虚拟机上运行的存储智能合约。 
  
等级3 本地存储。只存储在本地，这对于点对点通信很有用，例如聊天程序，信息不泄漏，是免费的。   
  
PoSt（Proof Of Spacetime)与PoRep(Proof Of Replication)共识是IPFS的两种共识机制，水果链使用独立于PoW方式对存储节点进行奖励。  
  
## 3. 未来研究方向   
* 改进所有节点的时间戳同步，而不需要中心化的NTP服务器。  
* 喜欢奖励基础设施里的激励技术，这样重度投资基础设施的投资人不会遭遇“被忽视”，“亏本”的问题。  
* 支持副本创建的分片技术，尽量减少被BFT会员会拒绝的交易集。  
* 添加零知识证明以增强隐私。  
* EVM、TVM和Linux容器技术的混合基础设施。  
* 改进虚拟机规范中的二进制数据编码方法，交易签名，收费表等章节。  
  
## 4. 建议  
水果链是PoW和BFT混合共识正确工作的核心机制，保证BFT委员会的正确选取，所以它的工作参数对链的工作稳定性有极大的影响，在已有的设计的基础上，分析更准确的工作参数，研究更完善的设计方案，可能是工作的重点。    
  
## 5. 读后感：  
通过混合共识机制或结构创新的共识机制来解决当前区块链面临的关键问题，将是下一步的发展方向，加强底层理论的研究，和技术应用，落地实现，与现实应用场景对接，扩展至分布式，高速率的应用场景，同时针对不同的商业应用给出最匹配，合理的解决方案。  
初链的设计方案，和研究探索精神值得学习。 
